<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ZIP Comparator (Client-Side) v4 </title>

  <!-- JSZip for reading zip files -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- diff-match-patch for text diffs -->
  <script src="https://cdn.jsdelivr.net/npm/diff-match-patch@1.0.5/index.min.js"></script>

  <style>
    :root {
      --bg:#0b1020;
      --card:#121a33;
      --muted:#9aa6c5;
      --text:#e7ecff;
      --accent:#7aa2ff;
      --bad:#ff7a7a;
      --good:#7affb2;
      --warn:#ffd37a;
    }

    body {
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:linear-gradient(180deg,#070a14,#0b1020 40%,#070a14);
      color:var(--text);
    }
    .wrap { max-width:1100px; margin:0 auto; padding:24px; }
    h1 { margin:0 0 8px; font-size:22px; }
    p { margin:8px 0; color:var(--muted); line-height:1.4; }

    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:14px; margin-top:16px; }
    .card {
      background:rgba(18,26,51,.85);
      border:1px solid rgba(122,162,255,.2);
      border-radius:14px;
      padding:14px;
      backdrop-filter: blur(8px);
    }
    .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    label { display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    input[type=file] { width:100%; }

    button {
      background:linear-gradient(90deg, rgba(122,162,255,.9), rgba(122,255,210,.8));
      border:none; color:#081025; font-weight:800; padding:10px 14px; border-radius:10px;
      cursor:pointer;
    }
    button:disabled { opacity:.5; cursor:not-allowed; }

    .navbtn {
      background:transparent;
      color:var(--text);
      border:1px solid rgba(231,236,255,.18);
      padding:7px 10px;
      border-radius:10px;
      font-weight:800;
      cursor:pointer;
    }
    .navbtn:hover { background:rgba(255,255,255,.05); }
    .navbtn:disabled { opacity:.45; cursor:not-allowed; }

    .pill { font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid rgba(231,236,255,.15); color:var(--muted); }
    .pill.good { border-color: rgba(122,255,178,.55); color: var(--good); }
    .pill.bad { border-color: rgba(255,122,122,.55); color: var(--bad); }
    .pill.warn { border-color: rgba(255,211,122,.55); color: var(--warn); }

    .results { margin-top:14px; display:grid; grid-template-columns: 1fr 1fr; gap:14px; }
    .list { max-height:260px; overflow:auto; border:1px solid rgba(231,236,255,.12); border-radius:12px; padding:10px; }
    .list button {
      background:transparent; color:var(--text); border:1px solid rgba(231,236,255,.12);
      padding:6px 10px; border-radius:10px; font-weight:700;
      cursor:pointer;
    }
    .item { display:flex; gap:10px; align-items:center; justify-content:space-between; padding:8px; border-radius:10px; }
    .item:hover { background:rgba(255,255,255,.04); }

    .path {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono";
      font-size:12px; color:#d8e0ff;
      overflow:hidden; text-overflow: ellipsis; white-space: nowrap;
      max-width: 660px;
    }

    .diffbox { margin-top:14px; }
    .diffmeta { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }

    pre {
      margin:0;
      background:rgba(10,14,28,.95);
      border:1px solid rgba(231,236,255,.14);
      border-radius:12px;
      padding:12px;
      overflow:auto;
      max-height: 460px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono";
      font-size:12px;
      line-height:1.5;
      white-space: pre-wrap;
      word-break: break-word;
      scroll-behavior: smooth;
    }

    /* Higher-contrast diff colors */
    .add {
      background: rgba(40, 220, 120, .28);
      border: 1px solid rgba(40, 220, 120, .55);
      color: rgba(235, 255, 245, .98);
      border-radius: 5px;
      padding: 0 2px;
    }
    .del {
      background: rgba(255, 85, 85, .28);
      border: 1px solid rgba(255, 85, 85, .55);
      color: rgba(255, 240, 240, .98);
      border-radius: 5px;
      padding: 0 2px;
      text-decoration: line-through;
    }

    /* Change chunk wrapper + active highlight */
    .chg { border-radius: 6px; padding: 0 2px; }
    .chg.active {
      outline: 2px solid rgba(122,162,255,.95);
      outline-offset: 3px;
      box-shadow: 0 0 0 3px rgba(122,162,255,.18), 0 0 18px rgba(122,162,255,.22);
    }

    /* Collapsed unchanged marker */
    .collapsed {
      display: inline-block;
      margin: 6px 0;
      padding: 4px 8px;
      border-radius: 10px;
      border: 1px dashed rgba(231,236,255,.22);
      color: rgba(231,236,255,.72);
      background: rgba(255,255,255,.03);
      font-style: italic;
    }

    .hint { font-size:12px; color:var(--muted); }
    .footer { margin-top:12px; font-size:12px; color:var(--muted); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono"; }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>ZIP Comparator (client-side)</h1>
    <p>
      Upload two ZIP files. This page compares their contents in your browser (no uploads).
      It shows added/removed/changed files and a diff for selected changes.
    </p>

    <div class="grid">
      <div class="card">
        <label>ZIP A</label>
        <input id="zipA" type="file" accept=".zip" />
        <p class="hint">Example: <span class="mono">Intake additional information (1).zip</span></p>
      </div>
      <div class="card">
        <label>ZIP B</label>
        <input id="zipB" type="file" accept=".zip" />
        <p class="hint">Example: <span class="mono">Intake additional information (3).zip</span></p>
      </div>
    </div>

    <div class="card" style="margin-top:14px;">
      <div class="row" style="justify-content:space-between;">
        <div class="row">
          <button id="compareBtn" disabled>Compare</button>
          <span id="status" class="pill">Waiting for files…</span>
        </div>
        <div class="row">
          <span class="pill good" id="countAdded">Added: 0</span>
          <span class="pill bad" id="countRemoved">Removed: 0</span>
          <span class="pill warn" id="countChanged">Changed: 0</span>
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <label class="hint" style="display:flex;align-items:center;gap:8px;">
          <input type="checkbox" id="semanticJson" checked />
          Semantic JSON diff (ignore key order / formatting)
        </label>
        <span class="pill">Keys: n/p/Home/End</span>
      </div>
    </div>

    <div class="results">
      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <strong>Changed files</strong>
          <span class="pill warn">click to view diff</span>
        </div>
        <div id="changedList" class="list" style="margin-top:10px;"></div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <strong>Added / Removed</strong>
          <span class="pill">paths</span>
        </div>

        <div class="row" style="gap:14px; margin-top:10px;">
          <div style="flex:1;">
            <div class="hint">Added in ZIP B</div>
            <div id="addedList" class="list" style="margin-top:8px;"></div>
          </div>
          <div style="flex:1;">
            <div class="hint">Removed from ZIP A</div>
            <div id="removedList" class="list" style="margin-top:8px;"></div>
          </div>
        </div>
      </div>
    </div>

<div class="card" style="margin-top:14px;">
  <div class="row" style="justify-content:space-between;">
    <strong>Summary</strong>
    <span id="summaryPill" class="pill">—</span>
  </div>
  <pre id="summaryOut" style="margin-top:10px;">Select a changed file to generate a summary.</pre>
</div>

    <div class="card diffbox">
      <div class="diffmeta">
        <strong>Diff</strong>
        <span id="diffPath" class="pill">No file selected</span>
        <span id="diffType" class="pill">—</span>

        <button id="prevChange" class="navbtn" disabled>← Prev</button>
        <button id="nextChange" class="navbtn" disabled>Next →</button>
        <span id="changeCounter" class="pill">0 / 0</span>
      </div>

      <pre id="diffOut">Select a changed file to see the diff here.</pre>

      <div class="footer">
        Notes:
        - Unchanged regions are collapsed when very long.
        - Keyboard: <span class="mono">n</span> next, <span class="mono">p</span> prev, <span class="mono">Home</span>/<span class="mono">End</span>.
      </div>
    </div>
  </div>

  

  <script>
    const zipAInput = document.getElementById('zipA');
    const zipBInput = document.getElementById('zipB');
    const compareBtn = document.getElementById('compareBtn');
    const statusEl = document.getElementById('status');

    const countAdded = document.getElementById('countAdded');
    const countRemoved = document.getElementById('countRemoved');
    const countChanged = document.getElementById('countChanged');

    const addedList = document.getElementById('addedList');
    const removedList = document.getElementById('removedList');
    const changedList = document.getElementById('changedList');

    const diffOut = document.getElementById('diffOut');
    const diffPath = document.getElementById('diffPath');
    const diffType = document.getElementById('diffType');

    const semanticJsonEl = document.getElementById('semanticJson');

    const prevChangeBtn = document.getElementById('prevChange');
    const nextChangeBtn = document.getElementById('nextChange');
    const changeCounterEl = document.getElementById('changeCounter');

    const dmp = new diff_match_patch();

    let zipAFile = null, zipBFile = null;
    let mapA = null, mapB = null; // path -> { isText, text, hash, size }

    // Diff navigation state
    let changeEls = [];
    let changeIdx = -1;

    function setStatus(text, cls) {
      statusEl.textContent = text;
      statusEl.className = `pill ${cls || ''}`.trim();
    }

    function enableIfReady() {
      compareBtn.disabled = !(zipAFile && zipBFile);
      setStatus(zipAFile && zipBFile ? 'Ready to compare' : 'Waiting for files…', zipAFile && zipBFile ? 'good' : '');
    }

    zipAInput.addEventListener('change', e => {
      zipAFile = e.target.files?.[0] || null;
      enableIfReady();
    });
    zipBInput.addEventListener('change', e => {
      zipBFile = e.target.files?.[0] || null;
      enableIfReady();
    });

    function clearDiffNav() {
      changeEls = [];
      changeIdx = -1;
      prevChangeBtn.disabled = true;
      nextChangeBtn.disabled = true;
      changeCounterEl.textContent = '0 / 0';
    }

    function clearUI() {
      addedList.innerHTML = '';
      removedList.innerHTML = '';
      changedList.innerHTML = '';
      diffOut.textContent = 'Select a changed file to see the diff here.';
      diffPath.textContent = 'No file selected';
      diffType.textContent = '—';
      countAdded.textContent = 'Added: 0';
      countRemoved.textContent = 'Removed: 0';
      countChanged.textContent = 'Changed: 0';
      clearDiffNav();
    }

    // Very small helper hash (not cryptographic) to compare binary quickly
    function fnv1a(buf) {
      let h = 0x811c9dc5;
      const v = new Uint8Array(buf);
      for (let i = 0; i < v.length; i++) {
        h ^= v[i];
        h = (h + ((h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24))) >>> 0;
      }
      return ('0000000' + h.toString(16)).slice(-8);
    }

    function looksText(u8) {
      let nul = 0, weird = 0;
      const len = Math.min(u8.length, 5000);
      for (let i = 0; i < len; i++) {
        const c = u8[i];
        if (c === 0) nul++;
        else if (c < 7 || (c > 13 && c < 32)) weird++;
      }
      if (nul > 0) return false;
      return weird / len < 0.02;
    }

    async function loadZipToMap(file) {
      const zip = await JSZip.loadAsync(file);
      const out = new Map();
      const entries = Object.values(zip.files).filter(f => !f.dir);

      for (const entry of entries) {
        const bytes = await entry.async('arraybuffer');
        const u8 = new Uint8Array(bytes);
        const isText = looksText(u8);

        let text = null;
        if (isText) {
          text = await entry.async('string');
          text = text.replace(/\r\n/g, '\n');
        }

        out.set(entry.name, {
          isText,
          text,
          hash: fnv1a(bytes),
          size: u8.length,
        });
      }
      return out;
    }

    // Semantic JSON: sort object keys recursively and pretty-print.
    function stableStringify(value) {
      const seen = new WeakSet();
      function canon(v) {
        if (v === null || typeof v !== 'object') return v;
        if (seen.has(v)) return '[Circular]';
        seen.add(v);
        if (Array.isArray(v)) return v.map(canon); // keep order (recommended)
        const out = {};
        for (const k of Object.keys(v).sort()) out[k] = canon(v[k]);
        return out;
      }
      return JSON.stringify(canon(value), null, 2);
    }

    function trySemanticJson(text) {
      const t = (text ?? '').trim();
      if (!t) return null;
      if (!(t.startsWith('{') || t.startsWith('['))) return null;
      try {
        const parsed = JSON.parse(t);
        return stableStringify(parsed);
      } catch {
        return null;
      }
    }

    function renderPathList(container, paths, kind) {
      container.innerHTML = '';
      if (!paths.length) {
        container.innerHTML = `<div class="hint" style="padding:8px;">None</div>`;
        return;
      }
      for (const p of paths) {
        const div = document.createElement('div');
        div.className = 'item';
        div.innerHTML = `
          <div class="path" title="${p}">${p}</div>
          <span class="pill ${kind}">${kind.toUpperCase()}</span>
        `;
        container.appendChild(div);
      }
    }

    function renderChangedList(paths) {
      changedList.innerHTML = '';
      if (!paths.length) {
        changedList.innerHTML = `<div class="hint" style="padding:8px;">No changed files</div>`;
        return;
      }

      for (const p of paths) {
        const row = document.createElement('div');
        row.className = 'item';

        const btn = document.createElement('button');
        btn.textContent = 'View diff';
        btn.addEventListener('click', () => showDiff(p));

        const left = document.createElement('div');
        left.className = 'path';
        left.title = p;
        left.textContent = p;

        row.appendChild(left);
        row.appendChild(btn);
        changedList.appendChild(row);
      }
    }

    function htmlEscape(s) {
      return (s ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    // Collapse long unchanged regions (measured by lines).
    // Keep a little context at start/end of that unchanged block.
    const COLLAPSE_IF_LINES_OVER = 120;
    const KEEP_CONTEXT_LINES = 18;

    function escapeCollapsedMarker(n) {
      return `<span class="collapsed">… ${n} unchanged lines hidden …</span>\n`;
    }

    function setActiveChange(idx) {
      if (!changeEls.length) {
        clearDiffNav();
        return;
      }
      idx = Math.max(0, Math.min(idx, changeEls.length - 1));
      changeEls.forEach(el => el.classList.remove('active'));
      changeIdx = idx;

      const el = changeEls[changeIdx];
      el.classList.add('active');
      el.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });

      prevChangeBtn.disabled = (changeIdx <= 0);
      nextChangeBtn.disabled = (changeIdx >= changeEls.length - 1);
      changeCounterEl.textContent = `${changeIdx + 1} / ${changeEls.length}`;
    }

    function refreshChangeList() {
      changeEls = Array.from(diffOut.querySelectorAll('.chg'));
      if (!changeEls.length) {
        clearDiffNav();
        return;
      }
      prevChangeBtn.disabled = false;
      nextChangeBtn.disabled = false;
      setActiveChange(0);
    }

    prevChangeBtn.addEventListener('click', () => setActiveChange(changeIdx - 1));
    nextChangeBtn.addEventListener('click', () => setActiveChange(changeIdx + 1));

    // Keyboard navigation: n/p/Home/End
    document.addEventListener('keydown', (e) => {
      if (!changeEls.length) return;

      const tag = (document.activeElement?.tagName || '').toLowerCase();
      if (tag === 'input' || tag === 'textarea') return;

      if (e.key === 'n' || e.key === 'N') { e.preventDefault(); setActiveChange(changeIdx + 1); }
      else if (e.key === 'p' || e.key === 'P') { e.preventDefault(); setActiveChange(changeIdx - 1); }
      else if (e.key === 'Home') { e.preventDefault(); setActiveChange(0); }
      else if (e.key === 'End') { e.preventDefault(); setActiveChange(changeEls.length - 1); }
      else if (e.key === 'Enter') { e.preventDefault(); setActiveChange(0); }
    });

    // Build diff HTML:
    // - wraps contiguous add/del regions in navigable chunks (.chg)
    // - collapses very long equal regions into an ellipsis marker
    function buildDiffHtml(diffs) {
      let html = '';
      let inChunk = false;
      let chunkType = '';

      function openChunk(cls) {
        inChunk = true;
        chunkType = cls;
        html += `<span class="chg ${cls}">`;
      }
      function closeChunk() {
        if (inChunk) html += `</span>`;
        inChunk = false;
        chunkType = '';
      }

      function maybeCollapseEqualText(equalText) {
        // Convert to lines (preserve trailing newline if exists)
        const lines = equalText.split('\n');
        const lineCount = lines.length - 1; // because split keeps last empty after trailing \n
        if (lineCount <= COLLAPSE_IF_LINES_OVER) {
          html += htmlEscape(equalText);
          return;
        }

        // Keep head/tail context
        const head = lines.slice(0, KEEP_CONTEXT_LINES).join('\n') + '\n';
        const tail = '\n' + lines.slice(Math.max(0, lines.length - KEEP_CONTEXT_LINES - 1)).join('\n');
        const hidden = Math.max(0, lineCount - (KEEP_CONTEXT_LINES * 2));

        html += htmlEscape(head);
        html += escapeCollapsedMarker(hidden);
        html += htmlEscape(tail);
      }

      for (const [op, data] of diffs) {
        if (op === 0) {
          closeChunk();
          maybeCollapseEqualText(data);
          continue;
        }

        const cls = (op === 1) ? 'add' : 'del';

        if (!inChunk) openChunk(cls);
        else if (chunkType !== cls) { closeChunk(); openChunk(cls); }

        html += htmlEscape(data);
      }

      closeChunk();
      return html;
    }

    function showDiff(path) {
      clearDiffNav();

      const a = mapA.get(path);
      const b = mapB.get(path);
      diffPath.textContent = path;

      if (!a || !b) {
        diffType.textContent = 'Missing on one side';
        diffOut.textContent = 'Cannot diff: file missing on one side.';
        return;
      }

      if (a.isText && b.isText) {
        const semanticOn = !!semanticJsonEl?.checked;

        let left = a.text ?? '';
        let right = b.text ?? '';

        if (semanticOn) {
          const canonA = trySemanticJson(left);
          const canonB = trySemanticJson(right);
          if (canonA !== null && canonB !== null) {
            left = canonA;
            right = canonB;
            diffType.textContent = 'Semantic JSON diff';
          } else {
            diffType.textContent = 'Text diff (JSON parse failed)';
          }
        } else {
          diffType.textContent = 'Text diff';
        }

        const diffs = dmp.diff_main(left, right);
        dmp.diff_cleanupSemantic(diffs);

        diffOut.innerHTML = buildDiffHtml(diffs) || '(no visible differences)';
        refreshChangeList();
        return;
      }

      diffType.textContent = 'Binary/hash diff';
      diffOut.textContent =
        `Binary or non-text content detected.\n\n` +
        `ZIP A: size=${a.size} bytes, hash=${a.hash}\n` +
        `ZIP B: size=${b.size} bytes, hash=${b.hash}\n`;
    }

    compareBtn.addEventListener('click', async () => {
      clearUI();
      setStatus('Loading ZIPs…', 'warn');
      compareBtn.disabled = true;

      try {
        [mapA, mapB] = await Promise.all([
          loadZipToMap(zipAFile),
          loadZipToMap(zipBFile)
        ]);

        const pathsA = new Set(mapA.keys());
        const pathsB = new Set(mapB.keys());

        const added = [...pathsB].filter(p => !pathsA.has(p)).sort();
        const removed = [...pathsA].filter(p => !pathsB.has(p)).sort();

        const common = [...pathsA].filter(p => pathsB.has(p));
        const changed = common.filter(p => {
          const aa = mapA.get(p), bb = mapB.get(p);
          return aa.hash !== bb.hash || aa.size !== bb.size;
        }).sort();

        countAdded.textContent = `Added: ${added.length}`;
        countRemoved.textContent = `Removed: ${removed.length}`;
        countChanged.textContent = `Changed: ${changed.length}`;

        renderPathList(addedList, added, 'good');
        renderPathList(removedList, removed, 'bad');
        renderChangedList(changed);

        setStatus(
          (changed.length === 0 && added.length === 0 && removed.length === 0)
            ? 'No differences found ✅'
            : 'Comparison complete',
          'good'
        );
      } catch (err) {
        console.error(err);
        setStatus('Error parsing ZIP(s)', 'bad');
        diffOut.textContent = String(err?.message || err);
      } finally {
        compareBtn.disabled = false;
      }
    });

    // -------------------------
// JSON semantic summary (no AI)
// -------------------------

const summaryOut = document.getElementById('summaryOut');
const summaryPill = document.getElementById('summaryPill');

// Tweak to your liking
const SUMMARY_MAX_LINES = 60;
const TOP_PATHS_TO_SHOW = 30;

// Common metadata/noise keys to ignore (matches any path segment)
const NOISE_KEYS = new Set([
  "created", "updated", "createdAt", "updatedAt", "lastPublished",
  "createdBy", "updatedBy", "lastModifiedBy",
  "version", "nameAndVersion", // <-- if you WANT these, remove them
  "__typename"
]);

// If you want to keep version/nameAndVersion in summary, comment them out above.

function tryParseJsonOrNull(text) {
  const t = (text ?? '').trim();
  if (!t) return null;
  if (!(t.startsWith('{') || t.startsWith('['))) return null;
  try { return JSON.parse(t); } catch { return null; }
}

function isPrimitive(v) {
  return v === null || typeof v !== 'object';
}

function shortVal(v, max = 80) {
  let s;
  if (typeof v === 'string') s = JSON.stringify(v);
  else if (typeof v === 'number' || typeof v === 'boolean' || v === null) s = String(v);
  else if (Array.isArray(v)) s = `[array len=${v.length}]`;
  else s = `{object keys=${Object.keys(v).length}}`;
  if (s.length > max) s = s.slice(0, max - 1) + '…';
  return s;
}

function pathToString(pathArr) {
  // Use JSON-pointer-ish style, but keep [i] for readability
  return pathArr.map(seg => typeof seg === 'number' ? `[${seg}]` : (seg.includes('/') ? `["${seg}"]` : `.${seg}`)).join('').replace(/^\./, '');
}

function pathHasNoise(pathArr) {
  return pathArr.some(seg => typeof seg === 'string' && NOISE_KEYS.has(seg));
}

// A few buckets tailored for your domain-ish data.
// You can add patterns as you see more diffs.
function bucketForPath(pathStr) {
  const p = pathStr;

  if (/tenantId|environment|releaseVersion|systemId|systemType/i.test(p)) return "Environment / Tenant";
  if (/version|nameAndVersion|engagementId|requestId|processId|taskId|id$/i.test(p)) return "IDs & Versions";
  if (/visible|clearOnHide|hidden|display|sections|grids|fields/i.test(p)) return "UI / Visibility";
  if (/status|processing|completed|started|estimatedCompletion|resubmission/i.test(p)) return "Workflow / Status";
  if (/amount|currency|money|cost|price/i.test(p)) return "Money";
  if (/contacts|requester|coOwners|members|users|groupIds/i.test(p)) return "People / Assignments";
  return "Other";
}

// Diff output record:
// { type: 'add'|'remove'|'change', pathArr, pathStr, before, after }
function diffJson(a, b, pathArr = [], out = []) {
  if (a === b) return out;

  // Handle primitives directly
  if (isPrimitive(a) || isPrimitive(b)) {
    out.push({ type: 'change', pathArr, pathStr: pathToString(pathArr), before: a, after: b });
    return out;
  }

  // Arrays
  if (Array.isArray(a) || Array.isArray(b)) {
    if (!Array.isArray(a) || !Array.isArray(b)) {
      out.push({ type: 'change', pathArr, pathStr: pathToString(pathArr), before: a, after: b });
      return out;
    }
    const max = Math.max(a.length, b.length);
    for (let i = 0; i < max; i++) {
      if (i >= a.length) out.push({ type: 'add', pathArr: [...pathArr, i], pathStr: pathToString([...pathArr, i]), before: undefined, after: b[i] });
      else if (i >= b.length) out.push({ type: 'remove', pathArr: [...pathArr, i], pathStr: pathToString([...pathArr, i]), before: a[i], after: undefined });
      else diffJson(a[i], b[i], [...pathArr, i], out);
    }
    return out;
  }

  // Objects
  const keys = new Set([...Object.keys(a), ...Object.keys(b)]);
  for (const k of [...keys].sort()) {
    const hasA = Object.prototype.hasOwnProperty.call(a, k);
    const hasB = Object.prototype.hasOwnProperty.call(b, k);
    const nextPath = [...pathArr, k];

    if (!hasA && hasB) out.push({ type: 'add', pathArr: nextPath, pathStr: pathToString(nextPath), before: undefined, after: b[k] });
    else if (hasA && !hasB) out.push({ type: 'remove', pathArr: nextPath, pathStr: pathToString(nextPath), before: a[k], after: undefined });
    else diffJson(a[k], b[k], nextPath, out);
  }
  return out;
}

function renderSummary(diffRecords) {
  // filter noise
  const meaningful = diffRecords.filter(r => !pathHasNoise(r.pathArr));

  const counts = {
    total: diffRecords.length,
    meaningful: meaningful.length,
    add: meaningful.filter(r => r.type === 'add').length,
    remove: meaningful.filter(r => r.type === 'remove').length,
    change: meaningful.filter(r => r.type === 'change').length,
  };

  // bucketize
  const buckets = new Map();
  for (const r of meaningful) {
    const b = bucketForPath(r.pathStr);
    if (!buckets.has(b)) buckets.set(b, []);
    buckets.get(b).push(r);
  }

  // Produce text
  const lines = [];
  lines.push(`Meaningful changes: ${counts.meaningful} (adds ${counts.add}, removes ${counts.remove}, value changes ${counts.change})`);
  lines.push('');

  // Bucket summary
  for (const [b, recs] of [...buckets.entries()].sort((x,y) => y[1].length - x[1].length)) {
    lines.push(`${b}: ${recs.length}`);
  }

  lines.push('');
  lines.push(`Top changes (up to ${TOP_PATHS_TO_SHOW}):`);

  const top = meaningful.slice()
    .sort((r1, r2) => {
      // Prefer value-changes over pure add/remove, then shorter paths
      const score = (r) => (r.type === 'change' ? 2 : 1) * 1000 - r.pathStr.length;
      return score(r2) - score(r1);
    })
    .slice(0, TOP_PATHS_TO_SHOW);

  for (const r of top) {
    if (r.type === 'change') {
      lines.push(`- ${r.pathStr}: ${shortVal(r.before)} → ${shortVal(r.after)}`);
    } else if (r.type === 'add') {
      lines.push(`+ ${r.pathStr}: ${shortVal(r.after)}`);
    } else {
      lines.push(`- ${r.pathStr}: ${shortVal(r.before)}`);
    }
  }

  // Trim lines to keep UI sane
  const clipped = lines.slice(0, SUMMARY_MAX_LINES);
  if (lines.length > SUMMARY_MAX_LINES) clipped.push(`… (${lines.length - SUMMARY_MAX_LINES} more lines) …`);

  summaryPill.textContent = `${counts.meaningful} meaningful`;
  summaryPill.className = counts.meaningful ? 'pill warn' : 'pill good';
  summaryOut.textContent = clipped.join('\n');
}

// Call this after you compute text diff (or semantic JSON strings) inside showDiff()
function summarizeIfJson(leftText, rightText) {
  const a = tryParseJsonOrNull(leftText);
  const b = tryParseJsonOrNull(rightText);

  if (!a || !b) {
    summaryPill.textContent = 'Not JSON';
    summaryPill.className = 'pill';
    summaryOut.textContent = 'Summary is available only when both sides are valid JSON.';
    return;
  }

  const records = diffJson(a, b);
  renderSummary(records);
}

  </script>
</body>
</html>
